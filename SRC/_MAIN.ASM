		include		"Debugger.asm"		include		"SRC/SYSTEM/RAM.I"		include		"SOUND/SOUNDRAM.I"		include		"SRC/SYSTEM/MACRO.I"		include		"SRC/SYSTEM/HEADER.ASM"		INT:ERROR:		move.l	#CRAMWRITE,	(VDPCTRL)		;	Set VDP control mode to manually write a palette to CRAM		move.w	#$000E,		VDPDATA			;	Palleting...		BRA.S		INT				INCLUDE		"SRC/SYSTEM/HBLANK.ASM"		INCLUDE		"SRC/SYSTEM/VBLANK.ASM"		INCLUDE		"SRC/SYSTEM/SETUP.ASM"		START:		tst.l	(z80_port_1_control).l ; test port A & B control registers		bne.s	PortA_Ok		tst.w	(z80_expansion_control).l ; test port C control registerPortA_Ok:		bne.s	SkipSetup ; Skip the VDP and Z80 setup code if port A, B or C is ok...?		lea	SetupValues(pc),a5	; Load setup values array address.		movem.w	(a5)+,d5-d7		movem.l	(a5)+,a0-a4		move.b	-$10FF(a1),d0	; get hardware version (from $A10001)		andi.b	#$F,d0		beq.s	SkipSecurity	; If the console has no TMSS, skip the security stuff.		move.l	#'SEGA',$2F00(a1) ; move "SEGA" to TMSS register ($A14000)SkipSecurity:		move.w	(a4),d0	; clear write-pending flag in VDP to prevent issues if the 68k has been reset in the middle of writing a command long word to the VDP.		moveq	#0,d0	; clear d0		movea.l	d0,a6	; clear a6		move.l	a6,usp	; set usp to $0		moveq	#$17,d1VDPInitLoop:		move.b	(a5)+,d5	; add $8000 to value		move.w	d5,(a4)		; move value to	VDP register		add.w	d7,d5		; next register		dbf	d1,VDPInitLoop				move.l	(a5)+,(a4)		move.w	d0,(a3)		; clear	the VRAM		move.w	d7,(a1)		; stop the Z80		move.w	d7,(a2)		; reset	the Z80WaitForZ80:		btst	d0,(a1)		; has the Z80 stopped?		bne.s	WaitForZ80	; if not, branch		moveq	#$25,d2Z80InitLoop:		move.b	(a5)+,(a0)+		dbf	d2,Z80InitLoop				move.w	d0,(a2)		move.w	d0,(a1)		; start	the Z80		move.w	d7,(a2)		; reset	the Z80ClrRAMLoop:		move.l	d0,-(a6)	; clear 4 bytes of RAM		dbf	d6,ClrRAMLoop	; repeat until the entire RAM is clear		move.l	(a5)+,(a4)	; set VDP display mode and increment mode		move.l	(a5)+,(a4)	; set VDP to CRAM write		moveq	#$1F,d3	; set repeat timesClrCRAMLoop:		move.l	d0,(a3)	; clear 2 palettes		dbf	d3,ClrCRAMLoop	; repeat until the entire CRAM is clear		move.l	(a5)+,(a4)	; set VDP to VSRAM write		moveq	#$13,d4ClrVSRAMLoop:		move.l	d0,(a3)	; clear 4 bytes of VSRAM.		dbf	d4,ClrVSRAMLoop	; repeat until the entire VSRAM is clear		moveq	#3,d5PSGInitLoop:		move.b	(a5)+,$11(a3)	; reset	the PSG		dbf	d5,PSGInitLoop	; repeat for other channels		move.w	d0,(a2)		movem.l	(a6),d0-a6	; clear all registers		move	#$2700,srSkipSetup:		LEA		$FF0000,	A6		MOVEQ	#0,	D7		MOVE.W	#($FE00/4)-1,	D6			@CLEARRAM:		MOVE.L	D7,	(A6)+		DBF		D6,	@CLEARRAM		BSR.W	INITVDP		BSR.W	INITSOUND		BSR.W	INITJOYPADS		MOVE.B	#0*4,	(GAMEMODE).W		MAINLOOP:		MOVE.B	(GAMEMODE).W,	D0		ANDI.W	#%00011100,	D0		JSR		@INDEX(PC,D0.W)		BRA.S	MAINLOOP			@INDEX:		BRA.W	LOGO		BRA.W	MAIN		RTS				INCLUDE		"SRC/SYSTEM/INITVDP.ASM"		INCLUDE		"SRC/SYSTEM/INITSOUND.ASM"		INCLUDE		"SRC/SYSTEM/INITJOYPADS.ASM"				INCLUDE		"SRC/SYSTEM/Kosinski.ASM"		INCLUDE		"SRC/SUB/READJOYPADS.ASM"		INCLUDE		"SRC/SUB/CLEARSCREEN.ASM"		INCLUDE		"SRC/SUB/DRAWTILEMAP.ASM"		INCLUDE		"SRC/SUB/VSYNC.ASM"		INCLUDE		"SRC/SUB/PLAYSOUND.ASM"		INCLUDE		"SRC/SUB/PALFADEIN.ASM"		INCLUDE		"SRC/SUB/PALFADEOUT.ASM"		INCLUDE		"SRC/SUB/PROCESSSPRITES.ASM"		INCLUDE		"SRC/SUB/RUNOBJECTS.ASM"		INCLUDE		"SRC/SUB/OBJECTFALL.ASM"				INCLUDE		"SRC/GAMEMODE/LOGO.ASM"		INCLUDE		"SRC/GAMEMODE/MAIN.ASM"				INCLUDE		"SRC/OBJ/SOUL.ASM"		INCLUDE		"SRC/OBJ/INTEGRITY.ASM"		INCLUDE		"SRC/OBJ/MENU HANDLE.ASM"			ALIGN	$2000		include	"SOUND/driver.asm"			ALIGN	$2000		include	"ErrorHandler.asm"